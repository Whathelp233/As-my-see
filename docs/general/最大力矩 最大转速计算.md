# æœºå™¨äººå…³èŠ‚åŠ›çŸ©ä¸è½¬é€Ÿè®¡ç®—ï¼šç†è®ºä¸å·¥ç¨‹å®è·µ
> æ–‡æ¡£çŠ¶æ€: æ·±åº¦ä¼˜åŒ–ç‰ˆæœ¬  
> æ›´æ–°æ—¶é—´: 2026å¹´02æœˆ27æ—¥
> æ¶µç›–ç”µæœºç‰¹æ€§ã€å‡é€Ÿæ¯”ã€åŠŸç‡åŒ¹é…ç­‰å®Œæ•´è®¡ç®—ä½“ç³»

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. åŸºæœ¬ç‰©ç†å…³ç³»
```
åŠŸç‡(P) = åŠ›çŸ©(Ï„) Ã— è§’é€Ÿåº¦(Ï‰)
P = Ï„ Ã— Ï‰

å…¶ä¸­:
- P: åŠŸç‡ (ç“¦ç‰¹, W)
- Ï„: åŠ›çŸ© (ç‰›é¡¿Â·ç±³, NÂ·m)
- Ï‰: è§’é€Ÿåº¦ (å¼§åº¦/ç§’, rad/s)
```

### 2. å‡é€Ÿæ¯”çš„å½±å“
```
ç”µæœºè¾“å‡ºåŠ›çŸ©(Ï„_motor) â†’ å‡é€Ÿå™¨ â†’ å…³èŠ‚è¾“å‡ºåŠ›çŸ©(Ï„_joint)
Ï„_joint = Ï„_motor Ã— i Ã— Î·

ç”µæœºè½¬é€Ÿ(Ï‰_motor) â†’ å‡é€Ÿå™¨ â†’ å…³èŠ‚è½¬é€Ÿ(Ï‰_joint)
Ï‰_joint = Ï‰_motor / i

å…¶ä¸­:
- i: å‡é€Ÿæ¯” (i > 1)
- Î·: ä¼ åŠ¨æ•ˆç‡ (0 < Î· â‰¤ 1ï¼Œé€šå¸¸0.8-0.95)
```

## ğŸ“Š å®Œæ•´è®¡ç®—ä½“ç³»

### 1. ç”µæœºç‰¹æ€§æ›²çº¿åˆ†æ
```python
# motor_characteristics.py
# ç”µæœºç‰¹æ€§åˆ†æä¸è®¡ç®—

import numpy as np
import matplotlib.pyplot as plt

class MotorAnalysis:
    """ç”µæœºç‰¹æ€§åˆ†æç±»"""
    
    def __init__(self, rated_voltage=24, rated_current=5, 
                 no_load_speed=3000, stall_torque=0.5):
        """
        åˆå§‹åŒ–ç”µæœºå‚æ•°
        
        å‚æ•°:
            rated_voltage: é¢å®šç”µå‹ (V)
            rated_current: é¢å®šç”µæµ (A)
            no_load_speed: ç©ºè½½è½¬é€Ÿ (RPM)
            stall_torque: å µè½¬åŠ›çŸ© (NÂ·m)
        """
        self.V = rated_voltage
        self.I_rated = rated_current
        self.Ï‰_nl = no_load_speed * (2 * np.pi / 60)  # RPM â†’ rad/s
        self.Ï„_stall = stall_torque
        
        # è®¡ç®—ç”µæœºå¸¸æ•°
        self.Kt = self.Ï„_stall / self.I_rated  # åŠ›çŸ©å¸¸æ•° (NÂ·m/A)
        self.Ke = self.V / self.Ï‰_nl          # åç”µåŠ¨åŠ¿å¸¸æ•° (V/(rad/s))
        self.R = self.V / self.I_rated        # ç”µæ¢ç”µé˜» (Î©)
        
    def calculate_torque_speed_curve(self):
        """è®¡ç®—åŠ›çŸ©-è½¬é€Ÿç‰¹æ€§æ›²çº¿"""
        # çº¿æ€§æ¨¡å‹: Ï‰ = Ï‰_nl - (Ï‰_nl / Ï„_stall) * Ï„
        torques = np.linspace(0, self.Ï„_stall, 100)
        speeds = self.Ï‰_nl - (self.Ï‰_nl / self.Ï„_stall) * torques
        
        # è®¡ç®—åŠŸç‡
        powers = torques * speeds
        
        return torques, speeds, powers
    
    def find_max_power_point(self):
        """æ‰¾åˆ°æœ€å¤§åŠŸç‡ç‚¹"""
        torques, speeds, powers = self.calculate_torque_speed_curve()
        max_power_idx = np.argmax(powers)
        
        return {
            'torque': torques[max_power_idx],
            'speed': speeds[max_power_idx],
            'power': powers[max_power_idx],
            'efficiency': powers[max_power_idx] / (self.V * self.I_rated)
        }
    
    def plot_characteristics(self):
        """ç»˜åˆ¶ç”µæœºç‰¹æ€§æ›²çº¿"""
        torques, speeds, powers = self.calculate_torque_speed_curve()
        max_point = self.find_max_power_point()
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
        
        # åŠ›çŸ©-è½¬é€Ÿæ›²çº¿
        ax1.plot(torques, speeds)
        ax1.scatter(max_point['torque'], max_point['speed'], 
                   color='red', s=100, label='æœ€å¤§åŠŸç‡ç‚¹')
        ax1.set_xlabel('åŠ›çŸ© (NÂ·m)')
        ax1.set_ylabel('è½¬é€Ÿ (rad/s)')
        ax1.set_title('åŠ›çŸ©-è½¬é€Ÿç‰¹æ€§æ›²çº¿')
        ax1.grid(True)
        ax1.legend()
        
        # åŠŸç‡æ›²çº¿
        ax2.plot(torques, powers)
        ax2.scatter(max_point['torque'], max_point['power'], 
                   color='red', s=100, label='æœ€å¤§åŠŸç‡ç‚¹')
        ax2.set_xlabel('åŠ›çŸ© (NÂ·m)')
        ax2.set_ylabel('åŠŸç‡ (W)')
        ax2.set_title('åŠŸç‡ç‰¹æ€§æ›²çº¿')
        ax2.grid(True)
        ax2.legend()
        
        plt.tight_layout()
        plt.show()
        
        return fig

# ç¤ºä¾‹ä½¿ç”¨
if __name__ == "__main__":
    # åˆ›å»ºä¸€ä¸ªç›´æµç”µæœºå®ä¾‹
    motor = MotorAnalysis(
        rated_voltage=24,
        rated_current=5,
        no_load_speed=3000,  # RPM
        stall_torque=0.5     # NÂ·m
    )
    
    print("ç”µæœºå‚æ•°:")
    print(f"åŠ›çŸ©å¸¸æ•° Kt = {motor.Kt:.4f} NÂ·m/A")
    print(f"åç”µåŠ¨åŠ¿å¸¸æ•° Ke = {motor.Ke:.4f} V/(rad/s)")
    print(f"ç”µæ¢ç”µé˜» R = {motor.R:.2f} Î©")
    
    max_point = motor.find_max_power_point()
    print("\næœ€å¤§åŠŸç‡ç‚¹:")
    print(f"åŠ›çŸ©: {max_point['torque']:.3f} NÂ·m")
    print(f"è½¬é€Ÿ: {max_point['speed']:.1f} rad/s ({max_point['speed']*60/(2*np.pi):.0f} RPM)")
    print(f"åŠŸç‡: {max_point['power']:.1f} W")
    print(f"æ•ˆç‡: {max_point['efficiency']*100:.1f}%")
    
    # ç»˜åˆ¶æ›²çº¿
    motor.plot_characteristics()
```

### 2. å‡é€Ÿå™¨é€‰æ‹©ä¸ä¼˜åŒ–
```python
# gearbox_optimization.py
# å‡é€Ÿå™¨ä¼˜åŒ–è®¡ç®—

import numpy as np
from scipy.optimize import minimize_scalar

class GearboxOptimizer:
    """å‡é€Ÿå™¨ä¼˜åŒ–ç±»"""
    
    def __init__(self, motor_torque_max, motor_speed_max, 
                 required_torque, required_speed,
                 gearbox_efficiency=0.9):
        """
        åˆå§‹åŒ–å‚æ•°
        
        å‚æ•°:
            motor_torque_max: ç”µæœºæœ€å¤§åŠ›çŸ© (NÂ·m)
            motor_speed_max: ç”µæœºæœ€å¤§è½¬é€Ÿ (rad/s)
            required_torque: å…³èŠ‚æ‰€éœ€åŠ›çŸ© (NÂ·m)
            required_speed: å…³èŠ‚æ‰€éœ€è½¬é€Ÿ (rad/s)
            gearbox_efficiency: å‡é€Ÿå™¨æ•ˆç‡
        """
        self.Ï„_m_max = motor_torque_max
        self.Ï‰_m_max = motor_speed_max
        self.Ï„_j_req = required_torque
        self.Ï‰_j_req = required_speed
        self.Î· = gearbox_efficiency
        
    def calculate_optimal_gear_ratio(self):
        """è®¡ç®—æœ€ä¼˜å‡é€Ÿæ¯”"""
        
        def objective_function(gear_ratio):
            """ç›®æ ‡å‡½æ•°ï¼šæœ€å°åŒ–åŠŸç‡éœ€æ±‚"""
            # è®¡ç®—å…³èŠ‚åŠ›çŸ©å’Œè½¬é€Ÿ
            Ï„_j = self.Ï„_m_max * gear_ratio * self.Î·
            Ï‰_j = self.Ï‰_m_max / gear_ratio
            
            # æ£€æŸ¥æ˜¯å¦æ»¡è¶³éœ€æ±‚
            if Ï„_j < self.Ï„_j_req or Ï‰_j < self.Ï‰_j_req:
                return float('inf')  # ä¸æ»¡è¶³éœ€æ±‚ï¼Œè¿”å›æ— ç©·å¤§
            
            # è®¡ç®—æ‰€éœ€åŠŸç‡
            power_required = self.Ï„_j_req * self.Ï‰_j_req / self.Î·
            
            # æ·»åŠ å‡é€Ÿæ¯”æƒ©ç½šé¡¹ï¼ˆé¿å…è¿‡å¤§å‡é€Ÿæ¯”ï¼‰
            penalty = 0.01 * gear_ratio
            
            return power_required + penalty
        
        # æœç´¢æœ€ä¼˜å‡é€Ÿæ¯”
        result = minimize_scalar(
            objective_function,
            bounds=(1, 100),  # å‡é€Ÿæ¯”èŒƒå›´
            method='bounded'
        )
        
        if result.success:
            optimal_ratio = result.x
            
            # è®¡ç®—å®é™…æ€§èƒ½
            Ï„_j_actual = self.Ï„_m_max * optimal_ratio * self.Î·
            Ï‰_j_actual = self.Ï‰_m_max / optimal_ratio
            power_actual = Ï„_j_actual * Ï‰_j_actual
            
            return {
                'optimal_ratio': optimal_ratio,
                'actual_torque': Ï„_j_actual,
                'actual_speed': Ï‰_j_actual,
                'actual_power': power_actual,
                'torque_margin': (Ï„_j_actual - self.Ï„_j_req) / self.Ï„_j_req * 100,
                'speed_margin': (Ï‰_j_actual - self.Ï‰_j_req) / self.Ï‰_j_req * 100
            }
        else:
            raise ValueError("æ— æ³•æ‰¾åˆ°æ»¡è¶³éœ€æ±‚çš„å‡é€Ÿæ¯”")
    
    def analyze_gear_ratios(self, ratios=None):
        """åˆ†æä¸åŒå‡é€Ÿæ¯”çš„æ€§èƒ½"""
        if ratios is None:
            ratios = np.geomspace(1, 100, 20)  # å‡ ä½•åºåˆ—
        
        results = []
        for ratio in ratios:
            Ï„_j = self.Ï„_m_max * ratio * self.Î·
            Ï‰_j = self.Ï‰_m_max / ratio
            power = Ï„_j * Ï‰_j
            
            results.append({
                'gear_ratio': ratio,
                'joint_torque': Ï„_j,
                'joint_speed': Ï‰_j,
                'power': power,
                'meets_torque': Ï„_j >= self.Ï„_j_req,
                'meets_speed': Ï‰_j >= self.Ï‰_j_req,
                'meets_both': Ï„_j >= self.Ï„_j_req and Ï‰_j >= self.Ï‰_j_req
            })
        
        return results

# ç¤ºä¾‹ä½¿ç”¨
if __name__ == "__main__":
    # æœºå™¨äººå…³èŠ‚éœ€æ±‚
    joint_requirements = {
        'required_torque': 20.0,   # NÂ·m
        'required_speed': 3.0      # rad/s
    }
    
    # ç”µæœºå‚æ•°
    motor_specs = {
        'max_torque': 0.5,        # NÂ·m
        'max_speed': 300 * (2*np.pi/60),  # rad/s
        'efficiency': 0.85
    }
    
    optimizer = GearboxOptimizer(
        motor_torque_max=motor_specs['max_torque'],
        motor_speed_max=motor_specs['max_speed'],
        required_torque=joint_requirements['required_torque'],
        required_speed=joint_requirements['required_speed'],
        gearbox_efficiency=motor_specs['efficiency']
    )
    
    # è®¡ç®—æœ€ä¼˜å‡é€Ÿæ¯”
    optimal = optimizer.calculate_optimal_gear_ratio()
    
    print("å…³èŠ‚éœ€æ±‚:")
    print(f"  åŠ›çŸ©: {joint_requirements['required_torque']} NÂ·m")
    print(f"  è½¬é€Ÿ: {joint_requirements['required_speed']} rad/s")
    
    print("\nç”µæœºå‚æ•°:")
    print(f"  æœ€å¤§åŠ›çŸ©: {motor_specs['max_torque']} NÂ·m")
    print(f"  æœ€å¤§è½¬é€Ÿ: {motor_specs['max_speed']:.1f} rad/s")
    
    print("\næœ€ä¼˜å‡é€Ÿæ¯”åˆ†æ:")
    print(f"  å‡é€Ÿæ¯”: {optimal['optimal_ratio']:.1f}")
    print(f"  å®é™…å…³èŠ‚åŠ›çŸ©: {optimal['actual_torque']:.1f} NÂ·m")
    print(f"  å®é™…å…³èŠ‚è½¬é€Ÿ: {optimal['actual_speed']:.2f} rad/s")
    print(f"  å®é™…åŠŸç‡: {optimal['actual_power']:.1f} W")
    print(f"  åŠ›çŸ©è£•åº¦: {optimal['torque_margin']:.1f}%")
    print(f"  è½¬é€Ÿè£•åº¦: {optimal['speed_margin']:.1f}%")
    
    # åˆ†æä¸åŒå‡é€Ÿæ¯”
    print("\nä¸åŒå‡é€Ÿæ¯”æ€§èƒ½åˆ†æ:")
    ratios = [10, 20, 30, 40, 50, 60]
    analysis = optimizer.analyze_gear_ratios(ratios)
    
    for result in analysis:
        status = "âœ“" if result['meets_both'] else "âœ—"
        print(f"{status} å‡é€Ÿæ¯” {result['gear_ratio']:3.0f}: "
              f"åŠ›çŸ©={result['joint_torque']:5.1f}NÂ·m, "
              f"è½¬é€Ÿ={result['joint_speed']:4.2f}rad/s, "
              f"åŠŸç‡={result['power']:6.1f}W")
```

### 3. å®Œæ•´æœºå™¨äººå…³èŠ‚è®¡ç®—
```python
# robot_joint_calculator.py
# å®Œæ•´æœºå™¨äººå…³èŠ‚è®¡ç®—ç³»ç»Ÿ

import numpy as np
from dataclasses import dataclass
from typing import List, Tuple
import matplotlib.pyplot as plt

@dataclass
class MotorSpec:
    """ç”µæœºè§„æ ¼"""
    name: str
    rated_voltage: float      # V
    rated_current: float      # A
    no_load_speed: float      # RPM
    stall_torque: float       # NÂ·m
    mass: float               # kg
    price: float              # å…ƒ
    efficiency: float = 0.85

@dataclass
class GearboxSpec:
    """å‡é€Ÿå™¨è§„æ ¼"""
    name: str
    ratio: float
    efficiency: float
    max_torque: float         # NÂ·m
    backlash: float           # å¼§åº¦
    mass: float               # kg
    price: float              # å…ƒ

@dataclass
class JointRequirement:
    """å…³èŠ‚éœ€æ±‚"""
    max_torque: float         # NÂ·m
    max_speed: float          # rad/s
    duty_cycle: float = 0.3   # å ç©ºæ¯”
    safety_factor: float = 1.5 # å®‰å…¨ç³»æ•°

class RobotJointCalculator:
    """æœºå™¨äººå…³èŠ‚è®¡ç®—å™¨"""
    
    def __init__(self):
        self.motors = self.load_motor_database()
        self.gearboxes = self.load_gearbox_database()
    
    def load_motor_database(self) -> List[MotorSpec]:
        """åŠ è½½ç”µæœºæ•°æ®åº“"""
        return [
            MotorSpec("Maxon EC45", 24, 2.3, 5600, 0.084, 0.32, 1500),
            MotorSpec("Maxon EC60", 48, 4.8, 8000, 0.228, 0.85, 2500),
            MotorSpec("Faulhaber 3242", 12, 1.2, 7900, 0.021, 0.085, 800),
            MotorSpec("Kollmorgen TBM", 48, 15, 4500, 1.2, 2.5, 5000),
            MotorSpec("Harmonic Drive CSF", 48, 8, 6000, 0.65, 1.8, 3500),
        ]
    
    def load_gearbox_database(self) -> List[GearboxSpec]:
        """åŠ è½½å‡é€Ÿå™¨æ•°æ®åº“"""
        return [
            GearboxSpec("Harmonic CSF-14", 50, 0.85, 14, 0.001, 0.12, 1200),
            GearboxSpec("Harmonic CSF-17", 100, 0.83, 17, 0.001, 0.15, 1500),
            GearboxSpec("Planetary 10:1", 10, 0.92, 30, 0.005, 0.25, 800),
            GearboxSpec("Planetary 50:1", 50, 0.90, 50, 0.005, 0.35, 1000),
            GearboxSpec("Planetary 100:1", 100, 0.88, 80, 0.005, 0.45, 1200),
        ]
    
    def calculate_joint_performance(self, motor: MotorSpec, 
                                   gearbox: GearboxSpec,
                                   requirement: JointRequirement) -> dict:
        """è®¡ç®—å…³èŠ‚æ€§èƒ½"""
        
        # è½¬æ¢å•ä½
        Ï‰_nl = motor.no_load_speed * (2 * np.pi / 60)  # RPM â†’ rad/s
        
        # è®¡ç®—å…³èŠ‚è¾“å‡º
        Ï„_joint_max = motor.stall_torque * gearbox.ratio * gearbox.efficiency
        Ï‰_joint_max = Ï‰_nl / gearbox.ratio
        
        # è®¡ç®—è¿ç»­å·¥ä½œåŠ›çŸ©ï¼ˆè€ƒè™‘å ç©ºæ¯”ï¼‰
        Ï„_continuous = motor.stall_torque * np.sqrt(requirement.duty_cycle)
        Ï„_joint_continuous = Ï„_continuous * gearbox.ratio * gearbox.efficiency
        
        # è®¡ç®—åŠŸç‡
        power_max = Ï„_joint_max * Ï‰_joint_max
        power_required = requirement.max_torque * requirement.max_speed
        
        # æ£€æŸ¥æ˜¯å¦æ»¡è¶³éœ€æ±‚ï¼ˆè€ƒè™‘å®‰å…¨ç³»æ•°ï¼‰
        Ï„_required = requirement.max_torque * requirement.safety_factor
        Ï‰_required = requirement.max_speed * requirement.safety_factor
        
        meets_torque = Ï„_joint_max >= Ï„_required
        meets_speed = Ï‰_joint_max >= Ï‰_required
        meets_power = power_max >= power_required
        
        # è®¡ç®—è´¨é‡å’Œæˆæœ¬
        total_mass = motor.mass + gearbox.mass
        total_cost = motor.price + gearbox.price
        
        # è®¡ç®—æ•ˆç‡
        system_efficiency = motor.efficiency * gearbox.efficiency
        
        return {
            'motor': motor.name,
            'gearbox': gearbox.name,
            'gear_ratio': gearbox.ratio,
            
            # æ€§èƒ½å‚æ•°
            'joint_torque_max': Ï„_joint_max,
            'joint_speed_max': Ï‰_joint_max,
            'joint_torque_continuous': Ï„_joint_continuous,
            'power_max': power_max,
            
            # éœ€æ±‚åŒ¹é…
            'meets_torque': meets_torque,
            'meets_speed': meets_speed,
            'meets_power': meets_power,
            'meets_all': meets_torque and meets_speed and meets_power,
            
            # ç³»ç»Ÿå‚æ•°
            'total_mass': total_mass,
            'total_cost': total_cost,
            'system_efficiency': system_efficiency,
            
            # è£•åº¦
            'torque_margin': (Ï„_joint_max - Ï„_required) / Ï„_required * 100,
            'speed_margin': (Ï‰_joint_max - Ï‰_required) / Ï‰_required * 100,
            'power_margin': (power_max - power_required) / power_required * 100,
        }
    
    def find_optimal_combinations(self, requirement: JointRequirement, 
                                 max_combinations=10) -> List[dict]:
        """å¯»æ‰¾æœ€ä¼˜ç”µæœº-å‡é€Ÿå™¨ç»„åˆ"""
        
        all_results = []
        
        for motor in self.motors:
            for gearbox in self.gearboxes:
                result = self.calculate_joint_performance(motor, gearbox, requirement)
                all_results.append(result)
        
        # æ’åºï¼šé¦–å…ˆæ»¡è¶³éœ€æ±‚ï¼Œç„¶åæŒ‰æˆæœ¬ã€è´¨é‡ã€æ•ˆç‡æ’åº
        def sort_key(result):
            if not result['meets_all']:
                return (0, float('inf'), float('inf'), 0)  # ä¸æ»¡è¶³éœ€æ±‚çš„æ”¾åé¢
            return (
                1,  # æ»¡è¶³éœ€æ±‚
                -result['system_efficiency'],  # æ•ˆç‡è¶Šé«˜è¶Šå¥½
                result['total_cost'],          # æˆæœ¬è¶Šä½è¶Šå¥½
                result['total_mass']           # è´¨é‡è¶Šè½»è¶Šå¥½
            )
        
        sorted_results = sorted(all_results, key=sort_key, reverse=True)
        return sorted_results[:max_combinations]
    
    def generate_report(self, requirement: JointRequirement):
        """ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š"""
        
        print("=" * 80)
        print("æœºå™¨äººå…³èŠ‚è®¾è®¡ä¸é€‰å‹æŠ¥å‘Š")
        print("=" * 80)
        
        print("\nğŸ“‹ å…³èŠ‚éœ€æ±‚è§„æ ¼:")
        print(f"  æœ€å¤§åŠ›çŸ©: {requirement.max_torque} NÂ·m")
        print(f"  æœ€å¤§è½¬é€Ÿ: {requirement.max_speed} rad/s")
        print(f"  å ç©ºæ¯”: {requirement.duty_cycle}")
        print(f"  å®‰å…¨ç³»æ•°: {requirement.safety_factor}")
        
        print("\nğŸ” æœ€ä¼˜ç»„åˆæ¨è (å‰5å):")
        optimal_combos = self.find_optimal_combinations(requirement, max_combinations=5)
        
        for i, combo in enumerate(optimal_combos, 1):
            status = "âœ…" if combo['meets_all'] else "âš ï¸"
            print(f"\n{i}. {status} {combo['motor']} + {combo['gearbox']}")
            print(f"   å‡é€Ÿæ¯”: {combo['gear_ratio']:.0f}")
            print(f"   æœ€å¤§åŠ›çŸ©: {combo['joint_torque_max']:.1f} NÂ·m")
            print(f"   æœ€å¤§è½¬é€Ÿ: {combo['joint_speed_max']:.2f} rad/s")
            print(f"   ç³»ç»Ÿæ•ˆç‡: {combo['system_efficiency']*100:.1f}%")
            print(f"   æ€»è´¨é‡: {combo['total_mass']:.2f} kg")
            print(f"   æ€»æˆæœ¬: {combo['total_cost']:.0f} å…ƒ")
        
        print("\nğŸ“ˆ æ€§èƒ½è£•åº¦åˆ†æ:")
        best_combo = optimal_combos[0]
        print(f"   åŠ›çŸ©è£•åº¦: {best_combo['torque_margin']:.1f}%")
        print(f"   è½¬é€Ÿè£•åº¦: {best_combo['speed_margin']:.1f}%")
        print(f"   åŠŸç‡è£•åº¦: {best_combo['power_margin']:.1f}%")
        
        return optimal_combos

# ç¤ºä¾‹ä½¿ç”¨
if __name__ == "__main__":
    calculator = RobotJointCalculator()
    
    # å®šä¹‰å…³èŠ‚éœ€æ±‚ï¼ˆä¾‹å¦‚ï¼šæœºå™¨äººæ‰‹è‡‚è‚˜å…³èŠ‚ï¼‰
    elbow_joint = JointRequirement(
        max_torque=25.0,      # NÂ·m
        max_speed=2.5,        # rad/s
        duty_cycle=0.3,       # 30%å ç©ºæ¯”
        safety_factor=1.5     # 1.5å€å®‰å…¨ç³»æ•°
    )
    
    print("ğŸ¤– æœºå™¨äººå…³èŠ‚è®¾è®¡ä¸é€‰å‹ç³»ç»Ÿ")
    print("=" * 50)
    
    results = calculator.generate_report(elbow_joint)
    
    # å¯è§†åŒ–åˆ†æ
    if results:
        best = results[0]
        
        # åˆ›å»ºæ€§èƒ½å¯¹æ¯”å›¾
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))
        
        # 1. åŠ›çŸ©-è½¬é€Ÿç‰¹æ€§
        ratios = np.array([10, 20, 30, 40, 50, 60, 80, 100])
        motor = calculator.motors[0]  # ä½¿ç”¨ç¬¬ä¸€ä¸ªç”µæœº
        
        Ï‰_nl = motor.no_load_speed * (2 * np.pi / 60)
        Ï„_stall = motor.stall_torque
        
        joint_torques = Ï„_stall * ratios * 0.85  # è€ƒè™‘æ•ˆç‡
        joint_speeds = Ï‰_nl / ratios
        
        axes[0, 0].plot(joint_torques, joint_speeds, 'b-', linewidth=2)
        axes[0, 0].scatter(best['joint_torque_max'], best['joint_speed_max'], 
                          color='red', s=100, label='æœ€ä¼˜ç»„åˆ')
        axes[0, 0].axhline(y=elbow_joint.max_speed * elbow_joint.safety_factor, 
                          color='green', linestyle='--', label='éœ€æ±‚è½¬é€Ÿ')
        axes[0, 0].axvline(x=elbow_joint.max_torque * elbow_joint.safety_factor, 
                          color='orange', linestyle='--', label='éœ€æ±‚åŠ›çŸ©')
        axes[0, 0].set_xlabel('å…³èŠ‚åŠ›çŸ© (NÂ·m)')
        axes[0, 0].set_ylabel('å…³èŠ‚è½¬é€Ÿ (rad/s)')
        axes[0, 0].set_title('åŠ›çŸ©-è½¬é€Ÿç‰¹æ€§æ›²çº¿')
        axes[0, 0].grid(True)
        axes[0, 0].legend()
        
        # 2. åŠŸç‡æ›²çº¿
        powers = joint_torques * joint_speeds
        axes[0, 1].plot(ratios, powers, 'g-', linewidth=2)
        axes[0, 1].scatter(best['gear_ratio'], best['power_max'], 
                          color='red', s=100)
        axes[0, 1].set_xlabel('å‡é€Ÿæ¯”')
        axes[0, 1].set_ylabel('æœ€å¤§åŠŸç‡ (W)')
        axes[0, 1].set_title('åŠŸç‡-å‡é€Ÿæ¯”å…³ç³»')
        axes[0, 1].grid(True)
        
        # 3. æ•ˆç‡åˆ†æ
        efficiencies = []
        for ratio in ratios:
            # ç®€åŒ–æ•ˆç‡è®¡ç®—
            efficiency = 0.85 * (1 - 0.001 * ratio)  # å‡é€Ÿæ¯”è¶Šå¤§æ•ˆç‡ç•¥é™
            efficiencies.append(efficiency)
        
        axes[1, 0].plot(ratios, efficiencies, 'purple-', linewidth=2)
        axes[1, 0].scatter(best['gear_ratio'], best['system_efficiency'], 
                          color='red', s=100)
        axes[1, 0].set_xlabel('å‡é€Ÿæ¯”')
        axes[1, 0].set_ylabel('ç³»ç»Ÿæ•ˆç‡')
        axes[1, 0].set_title('æ•ˆç‡-å‡é€Ÿæ¯”å…³ç³»')
        axes[1, 0].grid(True)
        
        # 4. æˆæœ¬-è´¨é‡åˆ†æ
        combos = calculator.find_optimal_combinations(elbow_joint, max_combinations=10)
        costs = [c['total_cost'] for c in combos if c['meets_all']]
        masses = [c['total_mass'] for c in combos if c['meets_all']]
        
        if costs and masses:
            axes[1, 1].scatter(costs, masses, s=100, alpha=0.6)
            axes[1, 1].scatter(best['total_cost'], best['total_mass'], 
                              color='red', s=200, label='æœ€ä¼˜ç»„åˆ')
            axes[1, 1].set_xlabel('æ€»æˆæœ¬ (å…ƒ)')
            axes[1, 1].set_ylabel('æ€»è´¨é‡ (kg)')
            axes[1, 1].set_title('æˆæœ¬-è´¨é‡åˆ†æ')
            axes[1, 1].grid(True)
            axes[1, 1].legend()
        
        plt.tight_layout()
        plt.show()

## ğŸ—ï¸ å·¥ç¨‹å®è·µæŒ‡å—

### 1. å®é™…åº”ç”¨æ¡ˆä¾‹ï¼šå…­è½´å·¥ä¸šæœºå™¨äººå…³èŠ‚è®¾è®¡
```python
# industrial_robot_joints.py
# å…­è½´å·¥ä¸šæœºå™¨äººå…³èŠ‚è®¾è®¡

class IndustrialRobotDesign:
    """å·¥ä¸šæœºå™¨äººå…³èŠ‚è®¾è®¡"""
    
    def __init__(self):
        self.joints = {
            'J1': {'type': 'æ—‹è½¬', 'max_torque': 150, 'max_speed': 1.5, 'duty': 0.2},
            'J2': {'type': 'æ—‹è½¬', 'max_torque': 120, 'max_speed': 1.8, 'duty': 0.3},
            'J3': {'type': 'æ—‹è½¬', 'max_torque': 100, 'max_speed': 2.0, 'duty': 0.4},
            'J4': {'type': 'æ—‹è½¬', 'max_torque': 30, 'max_speed': 3.0, 'duty': 0.5},
            'J5': {'type': 'æ—‹è½¬', 'max_torque': 20, 'max_speed': 3.5, 'duty': 0.6},
            'J6': {'type': 'æ—‹è½¬', 'max_torque': 10, 'max_speed': 4.0, 'duty': 0.7},
        }
    
    def design_all_joints(self):
        """è®¾è®¡æ‰€æœ‰å…³èŠ‚"""
        calculator = RobotJointCalculator()
        
        print("å…­è½´å·¥ä¸šæœºå™¨äººå…³èŠ‚è®¾è®¡")
        print("=" * 60)
        
        for joint_name, specs in self.joints.items():
            requirement = JointRequirement(
                max_torque=specs['max_torque'],
                max_speed=specs['max_speed'],
                duty_cycle=specs['duty'],
                safety_factor=1.5
            )
            
            print(f"\nğŸ”§ {joint_name}å…³èŠ‚ ({specs['type']}):")
            print(f"  éœ€æ±‚: {specs['max_torque']}NÂ·m @ {specs['max_speed']}rad/s")
            
            combos = calculator.find_optimal_combinations(requirement, max_combinations=1)
            if combos:
                best = combos[0]
                print(f"  æ¨è: {best['motor']} + {best['gearbox']}")
                print(f"  å‡é€Ÿæ¯”: {best['gear_ratio']:.0f}")
                print(f"  åŠŸç‡: {best['power_max']:.0f}W")
                print(f"  æˆæœ¬: {best['total_cost']:.0f}å…ƒ")
```

### 2. åŠ¨æ€è´Ÿè½½è®¡ç®—
```python
# dynamic_load_calculation.py
# åŠ¨æ€è´Ÿè½½è®¡ç®—

import numpy as np

class DynamicLoadCalculator:
    """åŠ¨æ€è´Ÿè½½è®¡ç®—å™¨"""
    
    def calculate_required_torque(self, mass, acceleration, 
                                 friction_coefficient=0.1,
                                 efficiency=0.85):
        """
        è®¡ç®—æ‰€éœ€åŠ›çŸ©
        
        å‚æ•°:
            mass: è´Ÿè½½è´¨é‡ (kg)
            acceleration: åŠ é€Ÿåº¦ (m/sÂ²)
            friction_coefficient: æ‘©æ“¦ç³»æ•°
            efficiency: ç³»ç»Ÿæ•ˆç‡
        """
        # é‡åŠ›åˆ†é‡ï¼ˆå‡è®¾æ°´å¹³è¿åŠ¨ï¼Œæ— é‡åŠ›å½±å“ï¼‰
        gravity_torque = 0
        
        # åŠ é€ŸåŠ›çŸ©
        acceleration_torque = mass * acceleration
        
        # æ‘©æ“¦åŠ›çŸ©
        friction_torque = mass * 9.81 * friction_coefficient
        
        # æ€»éœ€æ±‚åŠ›çŸ©
        total_torque = (acceleration_torque + friction_torque + gravity_torque)
        
        # è€ƒè™‘æ•ˆç‡
        motor_torque = total_torque / efficiency
        
        return {
            'acceleration_torque': acceleration_torque,
            'friction_torque': friction_torque,
            'gravity_torque': gravity_torque,
            'total_torque': total_torque,
            'motor_torque': motor_torque
        }
    
    def calculate_trajectory_torque(self, trajectory, motor_params):
        """
        è®¡ç®—è½¨è¿¹è·Ÿè¸ªæ‰€éœ€åŠ›çŸ©
        
        å‚æ•°:
            trajectory: è½¨è¿¹æ•°æ® [æ—¶é—´, ä½ç½®, é€Ÿåº¦, åŠ é€Ÿåº¦]
            motor_params: ç”µæœºå‚æ•°
        """
        times, positions, velocities, accelerations = trajectory
        
        required_torques = []
        
        for acc in accelerations:
            torque = self.calculate_required_torque(
                mass=motor_params['load_mass'],
                acceleration=acc,
                friction_coefficient=motor_params['friction'],
                efficiency=motor_params['efficiency']
            )
            required_torques.append(torque['motor_torque'])
        
        return {
            'max_torque': np.max(required_torques),
            'rms_torque': np.sqrt(np.mean(np.square(required_torques))),
            'peak_to_rms': np.max(required_torques) / np.sqrt(np.mean(np.square(required_torques))),
            'torque_profile': required_torques
        }
```

## ğŸ“š å­¦ä¹ èµ„æºä¸è¿›é˜¶

### æ¨èä¹¦ç±
1. **ã€Šæœºå™¨äººå­¦å¯¼è®ºã€‹** - John J. Craig
2. **ã€Šç°ä»£æœºå™¨äººå­¦ã€‹** - Kevin M. Lynch, Frank C. Park
3. **ã€Šç”µæœºä¸æ‹–åŠ¨ã€‹** - æ·±å…¥ç†è§£ç”µæœºåŸç†
4. **ã€Šæœºæ¢°è®¾è®¡æ‰‹å†Œã€‹** - å‡é€Ÿå™¨è®¾è®¡å‚è€ƒ

### åœ¨çº¿èµ„æº
- **MIT OpenCourseWare**: "Introduction to Robotics"
- **Coursera**: "Robotics: Aerial Robotics"
- **ROS Wiki**: http://wiki.ros.org
- **RobotShop Community**: https://www.robotshop.com/community/

### ä»¿çœŸå·¥å…·
1. **MATLAB/Simulink**: æ§åˆ¶ç³»ç»Ÿä»¿çœŸ
2. **Gazebo**: æœºå™¨äººç‰©ç†ä»¿çœŸ
3. **Webots**: ä¸“ä¸šæœºå™¨äººä»¿çœŸ
4. **CoppeliaSim**: åŸåV-REP

## ğŸš€ å®é™…é¡¹ç›®åº”ç”¨

### é¡¹ç›®1ï¼šåä½œæœºå™¨äººå…³èŠ‚è®¾è®¡
```python
# collaborative_robot_design.py
# åä½œæœºå™¨äººå…³èŠ‚è®¾è®¡

def design_collaborative_robot():
    """è®¾è®¡åä½œæœºå™¨äººå…³èŠ‚"""
    
    # åä½œæœºå™¨äººå…¸å‹è§„æ ¼
    joint_specs = [
        {'name': 'Base', 'torque': 50, 'speed': 2.0, 'payload': 5},
        {'name': 'Shoulder', 'torque': 40, 'speed': 2.5, 'payload': 5},
        {'name': 'Elbow', 'torque': 30, 'speed': 3.0, 'payload': 5},
        {'name': 'Wrist1', 'torque': 10, 'speed': 4.0, 'payload': 3},
        {'name': 'Wrist2', 'torque': 8, 'speed': 4.5, 'payload': 3},
        {'name': 'Wrist3', 'torque': 5, 'speed': 5.0, 'payload': 3},
    ]
    
    calculator = RobotJointCalculator()
    
    print("ğŸ¤ åä½œæœºå™¨äººå…³èŠ‚è®¾è®¡")
    print("=" * 50)
    
    total_cost = 0
    total_mass = 0
    
    for spec in joint_specs:
        requirement = JointRequirement(
            max_torque=spec['torque'],
            max_speed=spec['speed'],
            duty_cycle=0.5,
            safety_factor=2.0  # åä½œæœºå™¨äººéœ€è¦æ›´é«˜å®‰å…¨ç³»æ•°
        )
        
        combos = calculator.find_optimal_combinations(requirement, max_combinations=1)
        if combos:
            best = combos[0]
            total_cost += best['total_cost']
            total_mass += best['total_mass']
            
            print(f"\n{spec['name']}å…³èŠ‚:")
            print(f"  ç”µæœº: {best['motor']}")
            print(f"  å‡é€Ÿå™¨: {best['gearbox']}")
            print(f"  å‡é€Ÿæ¯”: {best['gear_ratio']:.0f}")
            print(f"  æˆæœ¬: {best['total_cost']:.0f}å…ƒ")
            print(f"  è´¨é‡: {best['total_mass']:.2f}kg")
    
    print(f"\nğŸ“Š æ€»ä½“ç»Ÿè®¡:")
    print(f"  æ€»æˆæœ¬: {total_cost:.0f}å…ƒ")
    print(f"  æ€»è´¨é‡: {total_mass:.2f}kg")
    print(f"  ä¼°ç®—å”®ä»·: {total_cost * 3:.0f}å…ƒ (3å€æˆæœ¬)")
```

### é¡¹ç›®2ï¼šæ— äººæœºèˆµæœºé€‰å‹
```python
# drone_servo_selection.py
# æ— äººæœºèˆµæœºé€‰å‹

class DroneServoSelector:
    """æ— äººæœºèˆµæœºé€‰å‹"""
    
    def select_servo_for_drone(self, drone_type, requirements):
        """
        ä¸ºæ— äººæœºé€‰æ‹©èˆµæœº
        
        å‚æ•°:
            drone_type: 'racing', 'cinematic', 'freestyle'
            requirements: å…·ä½“è¦æ±‚å­—å…¸
        """
        
        # ä¸åŒç±»å‹æ— äººæœºçš„å…¸å‹éœ€æ±‚
        type_requirements = {
            'racing': {
                'response_time': 0.05,      # ç§’
                'torque': 2.0,              # NÂ·m
                'speed': 8.0,               # rad/s
                'weight_limit': 0.05,       # kg
                'reliability': 'high'
            },
            'cinematic': {
                'response_time': 0.1,
                'torque': 1.5,
                'speed': 6.0,
                'weight_limit': 0.08,
                'reliability': 'very_high'
            },
            'freestyle': {
                'response_time': 0.08,
                'torque': 2.5,
                'speed': 7.0,
                'weight_limit': 0.07,
                'reliability': 'high'
            }
        }
        
        req = type_requirements.get(drone_type, type_requirements['racing'])
        
        print(f"ğŸš {drone_type.upper()}æ— äººæœºèˆµæœºé€‰å‹")
        print("=" * 50)
        print(f"éœ€æ±‚è§„æ ¼:")
        print(f"  å“åº”æ—¶é—´: <{req['response_time']}s")
        print(f"  åŠ›çŸ©: >{req['torque']}NÂ·m")
        print(f"  è½¬é€Ÿ: >{req['speed']}rad/s")
        print(f"  é‡é‡é™åˆ¶: <{req['weight_limit']}kg")
        print(f"  å¯é æ€§: {req['reliability']}")
        
        # è¿™é‡Œåº”è¯¥è¿æ¥èˆµæœºæ•°æ®åº“è¿›è¡Œé€‰å‹
        # å®é™…é¡¹ç›®ä¸­å¯ä»¥ä»æ•°æ®åº“æŸ¥è¯¢
        
        return req
```

## ğŸ”§ è°ƒè¯•ä¸æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜
1. **åŠ›çŸ©ä¸è¶³**
   - æ£€æŸ¥å‡é€Ÿæ¯”æ˜¯å¦åˆé€‚
   - éªŒè¯ç”µæœºé€‰å‹
   - æ£€æŸ¥ç”µæºç”µå‹

2. **è½¬é€Ÿä¸è¾¾æ ‡**
   - æ£€æŸ¥å‡é€Ÿæ¯”æ˜¯å¦è¿‡å¤§
   - éªŒè¯è´Ÿè½½æ˜¯å¦è¿‡é‡
   - æ£€æŸ¥æ§åˆ¶ç³»ç»Ÿå¸¦å®½

3. **è¿‡çƒ­é—®é¢˜**
   - æ£€æŸ¥å ç©ºæ¯”è®¾ç½®
   - æ”¹å–„æ•£çƒ­